name: "Test Connectivity & Run SSH Commands on Failure"

on:
  workflow_dispatch:
    inputs:
      custom_command:
        description: '要执行的自定义命令'
        required: false
  schedule:
    - cron: "*/10 * * * *" # 修改这里的同时请记得修改RUN_INTERVAL_MINUTES变量

env:
  RUN_INTERVAL_MINUTES: 10
  ACCOUNTS_JSON: ${{ secrets.ACCOUNTS_JSON }}
  TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  SOCKS5_PROXY: ${{ secrets.SOCKS5_PROXY }}
  CUSTOM_COMMAND: ${{ github.event.inputs.custom_command || vars.CUSTOM_COMMAND || secrets.CUSTOM_COMMAND }}
  TARGET_HOST: ${{ secrets.TARGET_HOST }}

defaults:
  run:
    shell: bash

jobs:
  run-all-tasks:
    runs-on: ubuntu-latest
    steps:
      - name: 0. Keep Render Alive by Accessing Endpoint
        run: |
          echo "访问保活地址 https://api.vqx.dpdns.org..."
          curl -s -L --max-time 10 "https://api.vqx.dpdns.org" || echo "访问失败，但继续执行后续步骤"

      - name: 1. Check Host Status
        id: check_host
        run: |
          echo "Pinging ${TARGET_HOST}..."
          response=$(curl -s -L --max-time 10 "${TARGET_HOST}")
          echo "Response received:"
          echo "$response"

          if echo "$response" | grep -q -E "Error 502|Request rejected"; then
            echo "Host is reporting an error. Proceeding with SSH tasks."
            echo "run_next_steps=true" >> $GITHUB_OUTPUT
          else
            echo "Host is working correctly. No action needed."
            echo "run_next_steps=false" >> $GITHUB_OUTPUT
            
            # Send Telegram notification only on the first run after 18:00 Beijing Time (10:00 UTC)
            CURRENT_HOUR_UTC=$(date -u +%H)
            PREVIOUS_HOUR_UTC=$(date -u -d "${RUN_INTERVAL_MINUTES} minutes ago" +%H)

            # Beijing time is UTC+8. 18:00 BJT is 10:00 UTC.
            # We send on the first run where the current hour is >= 10 and the previous hour was < 10.
            # This ensures the notification is sent only once per day when the status is OK.
            if [[ "$CURRENT_HOUR_UTC" -ge 10 && "$PREVIOUS_HOUR_UTC" -lt 10 ]]; then
              OK_MSG="✅ 主机 ${TARGET_HOST} 工作正常，无需执行任何操作。"
              curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${TELEGRAM_CHAT_ID}" \
                --data-urlencode text="$(echo -e "$OK_MSG")"
            fi
          fi

      - name: 2. Checkout repository
        if: steps.check_host.outputs.run_next_steps == 'true'
        uses: actions/checkout@v4

      - name: 3. Set up SSHPass and ProxyChains
        if: steps.check_host.outputs.run_next_steps == 'true'
        run: |
          sudo apt-get update && sudo apt-get install -y sshpass jq curl netcat-openbsd proxychains4
          AVAILABLE_PROXY=""
          PROXY_REPORT=""
          
          while read -r proxy; do
            [ -z "$proxy" ] && continue
          
            PROTO=$(echo "$proxy" | cut -d: -f1)
            USERPASS=$(echo "$proxy" | cut -d/ -f3 | cut -d@ -f1)
            if [[ "$USERPASS" == *:* ]]; then
              USER=$(echo "$USERPASS" | cut -d: -f1)
              PASS=$(echo "$USERPASS" | cut -d: -f2)
            else
              USER=""
              PASS=""
            fi
            HOST=$(echo "$proxy" | cut -d@ -f2 | cut -d: -f1)
            PORT=$(echo "$proxy" | rev | cut -d: -f1 | rev)
          
            if nc -z -w3 "$HOST" "$PORT"; then
              PROXY_REPORT="${PROXY_REPORT}✅ $proxy (可用)\n"
              if [ -n "$USER" ] && [ -n "$PASS" ]; then
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' '$USER' '$PASS' > /etc/proxychains4.conf"
              else
                sudo bash -c "printf 'strict_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n[ProxyList]\n%s %s %s\n' \
                  '$PROTO' '$HOST' '$PORT' > /etc/proxychains4.conf"
              fi
              AVAILABLE_PROXY="$proxy"
              break
            else
              PROXY_REPORT="${PROXY_REPORT}❌ $proxy (不可用)\n"
            fi
          done <<< "$SOCKS5_PROXY"
          
          if [ -z "$AVAILABLE_PROXY" ]; then
            FAIL_MSG="❌ 没有可用的 SOCKS5 代理\n${PROXY_REPORT}任务终止 at $(date '+%Y-%m-%d %H:%M:%S')"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" \
              --data-urlencode text="$(echo -e "$FAIL_MSG")"
            exit 1
          else
            echo "本次使用代理: $AVAILABLE_PROXY"
            echo "$AVAILABLE_PROXY" > selected_proxy.txt
            echo -e "$PROXY_REPORT" > proxy_report.txt
            echo "==== proxychains4.conf ===="
            cat /etc/proxychains4.conf
          fi
      - name: 4. Create accounts.json
        if: steps.check_host.outputs.run_next_steps == 'true'
        run: echo "$ACCOUNTS_JSON" > accounts.json

      - name: 5. Generate and execute SSH commands (via proxy)
        if: steps.check_host.outputs.run_next_steps == 'true'
        run: |
          OUTPUT_FILE="ssh_output.txt"
          : > "$OUTPUT_FILE"
          while IFS= read -r account; do
            username=$(echo "$account" | jq -r '.username')
            password=$(echo "$account" | jq -r '.password')
            ssh_addr=$(echo "$account" | jq -r '.panel')
            echo "===== $username@$ssh_addr =====" | tee -a "$OUTPUT_FILE"
            proxychains4 sshpass -p "$password" ssh -o StrictHostKeyChecking=no "$username@$ssh_addr" "$CUSTOM_COMMAND" 2>&1 | tee -a "$OUTPUT_FILE"
            echo "" >> "$OUTPUT_FILE"
          done < <(jq -c '.[]' accounts.json)
      - name: 6. Send Telegram notification with output
        if: always() && steps.check_host.outputs.run_next_steps == 'true'
        run: |
          STATUS="✅ 侦测到服务异常，已执行重启命令"
          if [ "${{ job.status }}" != "success" ]; then
            STATUS="❌ 侦测到服务异常，但重启命令执行失败"
          fi
          PROXY_INFO="$(cat proxy_report.txt 2>/dev/null || echo '无代理信息')"
          MSG="$(cat ssh_output.txt)"
          MSG_TRUNC="${MSG:0:3500}"
          FULL_MSG="$STATUS\n本次代理检测:\n$PROXY_INFO\n执行时间: $(date '+%Y-%m-%d %H:%M:%S')\n\`\`\`\n$MSG_TRUNC\n\`\`\`"
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d chat_id="${TELEGRAM_CHAT_ID}" \
            -d parse_mode="Markdown" \
            --data-urlencode text="$(echo -e "$FULL_MSG")"

